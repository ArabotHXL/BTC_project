You are a senior TypeScript / Next.js engineer.  
Goal: Implement **end-to-end encryption for miner connection settings** in this repo (HashInsight app), so that:

- The **farm owner / site owner** enters miner connection info in the app.
- The **browser encrypts** this data using a passphrase/key known only to the farm owner / site owner.
- The backend **stores ciphertext only** (no plaintext IP/username/password).
- When the farm owner / site owner needs to view/edit, the browser fetches ciphertext and **decrypts locally**.
- The backend must **never see plaintext** and must not be able to decrypt.

Do not change unrelated logic. Integrate cleanly with existing models/API/pages in this repo.

---

## 0. General Constraints

- Stack: use the existing project stack (Next.js + React + Node/TypeScript).
- Encryption:
  - Use **Web Crypto API in the browser** (`window.crypto.subtle`) for encrypt/decrypt.
  - Algorithm: **AES-256-GCM**.
  - Key derivation: **PBKDF2** (or a similar KDF Web Crypto supports), with random salt per secret.
- Backend:
  - Only stores **ciphertext blocks** and metadata.
  - **Never logs or manipulates decrypted miner connection info.**
- Types: use strict TypeScript everywhere.

> Important: Do **not** implement key recovery or server-side decryption.  
> If the server can recover keys or decrypt data, then it is no longer true that *only the farm owner / site owner who holds the passphrase* can see miner connection details.

---

## 1. Define Data Types

Create a shared TS types module (or extend an existing one) for miner connection secrets, e.g.:

**File:** `src/types/minerSecrets.ts` (adjust path to match project conventions)

```ts
export interface MinerConnectionPlain {
  host: string;
  port: number;
  username?: string;
  password?: string;
  apiPort?: number; // e.g. 4028 for CGMiner
}

export interface EncryptedBlock {
  ciphertext: string;  // base64
  iv: string;          // base64
  salt: string;        // base64
  algo: "AES-256-GCM";
  version: number;     // start with 1, allow upgrade later
}
If there is already a Miner model/interface, do not duplicate; extend it to optionally include:

ts
复制代码
encryptedConnection?: EncryptedBlock;
This represents a miner connection secret that only the farm owner / site owner can decrypt.

2. Frontend Crypto Utilities (client-side only)
Create a client-side crypto utility that:

Derives a symmetric key from a passphrase + salt.

Encrypts/decrypts MinerConnectionPlain → EncryptedBlock.

File: src/lib/crypto/minerSecrets.ts (or similar)

Requirements:

Mark the module (or functions) as client-only where needed:

Use 'use client' in React components where you call Web Crypto.

For utility functions, detect typeof window !== "undefined" and never use window.crypto on the server.

Implement:

ts
复制代码
export async function deriveKeyFromPassphrase(
  passphrase: string,
  saltBase64: string
): Promise<CryptoKey> { ... }

export async function encryptMinerConnection(
  plain: MinerConnectionPlain,
  passphrase: string
): Promise<EncryptedBlock> { ... }

export async function decryptMinerConnection(
  block: EncryptedBlock,
  passphrase: string
): Promise<MinerConnectionPlain> { ... }
Implementation details:

Generate:

salt: 16 random bytes → base64.

iv: 12 random bytes → base64 (suitable for AES-GCM).

deriveKeyFromPassphrase:

Use TextEncoder to encode passphrase.

Use PBKDF2 with SHA-256 and sufficient iterations (e.g. 100 000+).

Import derived bits as AES-GCM key with 256-bit length.

encryptMinerConnection:

JSON.stringify(plain) → Uint8Array via TextEncoder.

Use crypto.subtle.encrypt with AES-GCM and the random iv.

Encode ciphertext, iv, salt as base64.

Return EncryptedBlock with algo: "AES-256-GCM", version: 1.

decryptMinerConnection:

Decode base64 salt/iv/ciphertext.

Derive key from passphrase + salt.

crypto.subtle.decrypt with AES-GCM.

Parse plaintext JSON into MinerConnectionPlain.

If decryption fails (wrong passphrase, corrupted data), throw a clear error.

Do not import Node crypto on the client; use Web Crypto.

3. Passphrase Handling (Client Side)
Implement a minimal passphrase flow that keeps the passphrase on the client only.

Create a simple React context or hook, e.g.:

File: src/contexts/MinerEncryptionContext.tsx

ts
复制代码
'use client';

import React, { createContext, useContext, useState } from "react";

interface MinerEncryptionContextValue {
  passphrase: string | null;
  setPassphrase: (p: string | null) => void;
}

const MinerEncryptionContext = createContext<MinerEncryptionContextValue | undefined>(undefined);

export const MinerEncryptionProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [passphrase, setPassphrase] = useState<string | null>(null);
  return (
    <MinerEncryptionContext.Provider value={{ passphrase, setPassphrase }}>
      {children}
    </MinerEncryptionContext.Provider>
  );
};

export function useMinerEncryption() {
  const ctx = useContext(MinerEncryptionContext);
  if (!ctx) throw new Error("useMinerEncryption must be used within MinerEncryptionProvider");
  return ctx;
}
Do not send passphrase to the server.

For now, it can live only in memory (per tab).

Optionally, add a TODO comment if you want to later add secure local persistence (Keychain, etc.), but don’t implement that unless the repo already has a pattern.

Wrap the relevant part of the app with this provider, e.g. in the miner management layout:

If using the App Router, create a 'use client' layout for the miner management section and wrap children with MinerEncryptionProvider.

If using the Pages Router, wrap _app.tsx or miner-specific pages.

4. Backend Model / Persistence
Locate where miners are stored (Prisma schema, TypeORM, Supabase, etc.).
Extend the model to store encryptedConnection as JSON/text:

If using Prisma, e.g. in schema.prisma:

prisma
复制代码
model Miner {
  id            String   @id @default(cuid())
  // ...existing fields...
  encryptedConnection Json? // or String? if you prefer serialized JSON
}
If using a different ORM or a custom DB layer, add an equivalent nullable column/field.

Run migrations if needed.

Important: do not add new columns for plaintext host, password, apiPort to store secrets.
Any existing plaintext fields must not be used for new miner connection secrets going forward.

The backend should be blind to miner connection details; it only stores ciphertext.

5. API Endpoints for Miner Secrets
Find the existing API for miners (e.g. /api/miners, /api/miners/[id]).

Add/extend an endpoint that handles encrypted connection block only:

For App Router: app/api/miners/[id]/connection/route.ts

For Pages Router: pages/api/miners/[id]/connection.ts

5.1 Request/response types
The endpoint should accept and return only the encrypted block, plus minimal metadata:

ts
复制代码
import type { EncryptedBlock } from "@/types/minerSecrets";

export interface SaveMinerConnectionRequest {
  encryptedConnection: EncryptedBlock;
}

export interface MinerConnectionResponse {
  encryptedConnection: EncryptedBlock | null;
}
5.2 Handler behavior
GET:

Auth: ensure the current user is the farm owner / site owner (or authorized user) and owns the miner (reuse existing auth/ownership checks).

Return { encryptedConnection } from DB (or null if none).

POST or PUT:

Auth: verify the current user can act as farm owner / site owner for this miner.

Validate payload shape (use Zod or existing validation helpers).

Persist encryptedConnection as-is (JSON or string).

Do not try to decrypt or log the plaintext.

Return updated { encryptedConnection }.

Never accept or log fields like host, password, apiPort in this API.
The server should only see EncryptedBlock, never miner secrets.

6. Integrate with “Add/Edit Miner” UI
Locate the pages/components where miner connection info is currently entered/edited, e.g. MinerForm, AddMinerPage, EditMinerPage.

6.1 On Save (Create/Update)
Replace any direct “send plaintext connection info to server” flow with:

Get passphrase from useMinerEncryption():

If passphrase is null, prompt the farm owner / site owner to input it (e.g. a modal or inline form).

Make it clear in the UI:

“This passphrase is used to encrypt your miner connection details.
We never send it to the server. If you forget it, you’ll need to re-enter these details.”

Build a MinerConnectionPlain object from the form fields.

Call encryptMinerConnection(plain, passphrase) to get EncryptedBlock.

Call the new/updated API endpoint with { encryptedConnection }.

Optionally, clear any plaintext sensitive values from local component state after successful save.

6.2 On Load (View/Edit)
Fetch miner details as usual.

Call GET /api/miners/[id]/connection to get { encryptedConnection }.

If encryptedConnection is present:

Ensure passphrase is available:

If not, prompt the farm owner / site owner to enter it.

Call decryptMinerConnection(encryptedConnection, passphrase):

If successful, populate form fields with MinerConnectionPlain.

If decryption fails (wrong passphrase, corrupted data), show a clear error:

“Unable to decrypt miner connection details. Please check your passphrase.”

Allow user to edit and re-save:

Use the same encrypt-then-POST flow on submit.

7. UX Copy / Safety Warnings
Add clear UX messaging in the miner settings UI, targeted at farm owners / site owners:

Example copy:

“Your miner connection details are encrypted end-to-end.
Only you, as the farm owner / site owner holding the passphrase, can decrypt and view them.
HashInsight servers only store ciphertext and cannot read your IP/credentials.
Keep your encryption passphrase safe – if you lose it, these details can’t be recovered and you’ll need to re-enter them.”

Add a “Reset connection info” action:

This deletes encryptedConnection for that miner so the farm owner / site owner can start over if they forget the passphrase.

It must not attempt to recover or partially decrypt anything.

8. Tests & Verification
Add unit tests (where the repo already uses a testing framework) for:

encryptMinerConnection / decryptMinerConnection:

Round trip: decrypt(encrypt(plain, passphrase), passphrase) === plain.

Wrong passphrase → throws or returns a decryption error.

API route:

Rejects requests from unauthorized users (non-owners).

Only accepts/returns EncryptedBlock, never plaintext fields.

Manual test flow:

As a farm owner / site owner:

Add a miner:

Enter IP + credentials.

Set passphrase.

Save.

Verify in DB that only encryptedConnection is stored, no plaintext.

Refresh the page:

Enter same passphrase.

Verify the form auto-fills with decrypted values.

Try wrong passphrase:

Ensure decryption fails and UX shows a helpful error.

Confirm that:

No server logs contain plaintext miner secrets.

There is no backend code path that performs decryption.

9. Non-Goals (Document as comments)
Do not implement key recovery or server-side decryption – that would break the guarantee that only the farm owner / site owner who holds the passphrase can see miner connection details.

Do not add unrelated features (site dashboards, boiler heat reuse, etc.) in this task.