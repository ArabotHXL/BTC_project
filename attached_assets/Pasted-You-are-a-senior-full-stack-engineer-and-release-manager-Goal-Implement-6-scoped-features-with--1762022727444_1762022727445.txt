You are a senior full-stack engineer and release manager. 
Goal: Implement 6 scoped features (with tests, events logging, demo toggles) in repo https://github.com/ArabotHXL/BTC_project and open PRs per feature.

## GLOBAL CONSTRAINTS / 全局约束
- Language: TypeScript/Node for backend modules; React/Next for dashboard; Python ONLY allowed in batch/ ETL utilities if needed.
- Timezone: America/New_York; all timestamps ISO8601 with 'Z' and an added local ET note in UI.
- Create a feature branch per module: 
  - feat/datahub-unified, feat/hosting-monitor, feat/events-pipeline, feat/web3-recon-mvp, feat/curtailment-loop, feat/miner-adapters
- Use pnpm if package manager exists; else npm. Add minimal CI (GitHub Actions) to run lint + tests.
- Add .env.example with required vars; NEVER commit secrets. Provide safe defaults + fallbacks.
- All actions/alerts/data fetches MUST append JSONL event records under events/YYYY-MM-DD/*.jsonl.
- Add a DEMO switch (env DEMO_MODE=1) to simulate miners + ETL for offline demo.
- When manual inputs exist for price/reward, replace with read-only display fed from DataHub; show Source + RefreshedAt in UI header.

## REPO PREP / 仓库准备
1) Clone repo; install deps. If monorepo not present, treat as root.
2) Ensure folders (create if missing): 
   api/, common/, dashboard/, monitoring/, modules/, batch/, database/, reports/, events/
3) Add shared types under common/types.ts and an EventLogger utility common/eventLogger.ts (see schema below).

### Event JSONL Schema (one-line JSON each)
{
  "ts":"2025-11-01T14:00:00Z",
  "type":"datahub.fetch|monitor.alert|monitor.ack|curtailment.plan|curtailment.execute|batch.etl|report.daily|email.sent",
  "source":"coingecko|blockchain_info|mempool|antminer|whatsminer|simulator|ui|system",
  "key":"btc_price_usd|difficulty|block_reward|network_hashrate|miner_id|wallet_xxx|rule_xxx",
  "status":"ok|timeout|error|triggered|acknowledged",
  "latency_ms":123,
  "details":{...},
  "actor":"system|user:<email>"
}

Export helper: common/eventLogger.ts with appendEvent(event), and a small writer that creates daily dir events/YYYY-MM-DD/.

## (1) Unified Real-time DataHub / 统一实时数据层
Branch: feat/datahub-unified

Create api/datahub/ with:
- api/datahub/index.ts: DataHub facade
- api/datahub/providers/: 
  - price.coingecko.ts (primary)
  - price.fallback.coindesk.ts (fallback)
  - chain.blockchaininfo.ts (difficulty, block_reward, hashrate primary)
  - chain.fallback.mempool.ts (fallback)
- common/cache.ts: in-memory LRU with TTL (e.g., 15–30s price, 5m difficulty/hashrate)
- common/retry.ts: backoff + timeout (8s per provider)
- Observability: every fetch logs an event (type=datahub.fetch, status ok/timeout/error, cache_hit flag in details)
- Fallback order: price -> CoinGecko -> CoinDesk; chain -> blockchain.info -> mempool.space (free endpoints)
- Env:
  DATAHUB_PRICE_TTL=30
  DATAHUB_CHAIN_TTL=300
  DATAHUB_TIMEOUT_MS=8000

UI integration:
- In dashboard/_app or top navbar, add a compact banner:
  "Source: <providerName> • Refreshed: <local ET time> • (read-only)"
- Remove manual price/reward inputs; keep read-only fields + timestamp.

Acceptance tests (jest):
- test/datahub.timeout.spec.ts — simulate provider timeout -> fallback used -> event logged.
- test/datahub.fallback.spec.ts — primary error -> fallback ok -> returns data.
- test/datahub.exception.spec.ts — provider throws -> handled, no crash, event logged, surfaces error state.

## (2) Hosting Monitor Page / 监控页
Branch: feat/hosting-monitor

In dashboard/ create monitoring page (dashboard/monitoring.tsx) OR a sub-app under monitoring/:
- Table columns: MinerID, Model, Status(Online/Offline), Hashrate(5m avg), Temp(°C), Fan RPM, Power(W), LastSeen.
- Sparkline: last 15 minutes hashrate mini-chart per row (simple inline SVG or tiny library).
- Data sources:
  - Metrics from modules/miner_adapters via an API route (api/monitor/miners.ts).
  - Top banner reads from DataHub (price/difficulty/hashrate) using the shared facade.
- DEMO toggle: if DEMO_MODE=1, use a simulator that produces 5 “fake miners” mixed with any available real ones.

Alert rules (monitoring/rules.ts):
- Offline > 2 min
- Temp > 85°C
- Hashrate drop > 15% vs 1h baseline
- Fan failure (RPM = 0 when powered)
On rule trigger: write event type=monitor.alert with trigger params; show badge in UI. Provide bulk actions bar (Demo: selectable miners; actions disabled or double-confirm if real).

Daily report:
- Create reports/generateDailyReport.ts to aggregate events into a markdown/HTML summary + CSV; also render a simple PDF (use a pure-TS HTML->PDF lib if available, else Node canvas/pdfkit).
- On build: npm script "report:daily" writes reports/YYYY-MM-DD/monitoring_report.(csv|pdf|html)

Acceptance:
- Firing any rule writes events/* jsonl.
- Running "npm run report:daily" generates daily monitoring report.

## (3) Events & Alerts Middleware / 事件与告警流水中间件
Branch: feat/events-pipeline

- Implement common/eventsMiddleware.ts that exposes:
  recordDataFetch(...), recordAlert(...), recordCommand(...), recordEmail(...)
  All use eventLogger.appendEvent.
- Email channel: add email/notifier.ts using SMTP creds from env (EMAIL_SMTP_HOST/PORT/USER/PASS). In DEMO_MODE, don't send — just log event email.sent with details and write a stub .eml file under reports/YYYY-MM-DD/.
- Templates come from OPERATIONS_MANUAL_EN.md: create email/templates/alert.hbs and recovery.hbs (Handlebars).
- Add an endpoint api/events/export?format=csv&since=24h to export last 24h events per miner/client.

Acceptance:
- Can replay 24h events filtered by miner/client.
- Export CSV works.
- Each alert is traceable to trigger parameters and an ack actor (POST api/events/ack).

## (4) Web3 Reconciliation MVP / 链上对账 MVP
Branch: feat/web3-recon-mvp

- batch/web3/etl.ts: Pull on-chain data via free endpoints (mempool.space + blockchain.info). DEMO mode uses fixtures.
  Tables (SQLite under database/web3.sqlite):
  - blocks(id, height, time, tx_count)
  - txs(txid, block_height, time, fee_sat, in_sum_sat, out_sum_sat)
  - tx_io(txid, vout_n, addr, value_sat, direction IN|OUT)
  - address_tags(addr, tag)
- batch/web3/reconcileDaily.ts:
  Input: configured wallet addresses (config/wallets.json)
  Output report fields per day: total_in, total_out, net, fees, model_revenue (from your ROI model snapshot if present; else compute theoretical from block reward * share estimate), delta_pct; if |delta| < 1% tag as rounding accepted (per your policy).
- Exports:
  - reports/YYYY-MM-DD/wallet_settlement.(csv|pdf)
- Wire the events: type=batch.etl for extraction + reconcile.

Acceptance:
- "npm run web3:etl -- --since=1d" populates SQLite.
- "npm run web3:recon -- --date=YYYY-MM-DD" writes CSV/PDF and matches schema in repo docs.

Env:
  MEMPOOL_BASE=https://mempool.space/api
  BLOCKCHAIN_INFO_BASE=https://blockchain.info

## (5) Curtailment Strategy (closed loop) / “限功率/节电”策略
Branch: feat/curtailment-loop

- modules/curtailment_service/index.ts
  Inputs: electricity_price (from DataHub or config), thresholds (config/curtailment.json), DEMO toggle
  Compute a plan: which miners to throttle/stop to meet target Curtailment % while minimizing revenue loss.
  Outputs:
    - A plan JSON (miner_id, action: throttle|stop, expected_savings, expected_revenue_impact)
    - Action dispatcher (DEMO: no real commands; real mode requires second confirmation)
- API routes:
  - POST api/curtailment/plan
  - POST api/curtailment/execute (requires confirm=true)
  - POST api/curtailment/rollback
- Log events: curtailment.plan / curtailment.execute; include before/after revenue vs power (overlay panel in UI).

Acceptance:
- UI shows before/after revenue & power comparison overlay.
- Actions recorded into events/ and reflected in daily report.

## (6) Miner Adapters / 矿机适配层 (Antminer first, WhatsMiner simulator)
Branch: feat/miner-adapters

Define interface: modules/miner_adapters/types.ts
