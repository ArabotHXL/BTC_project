# HashInsight Miner Backend API — Quickstart, Tests & Deployment

> 一键跑起来（内存版） → 加上自动化测试 → 再给 Docker 部署脚本。现已支持**三套策略同时存在**：
>
> * 去重策略：`prefer_import` / `prefer_existing` / `reject_conflict`（支持**每次导入覆盖**）
> * 模板模式：`with_example` / `header_only`（支持**请求里切换**）
> * 鉴权模式：`dev_open` / `jwt` / `jwt_mtls`（PoC 用 dev，生产再收紧）

---

## 0) Prerequisites / 先决条件

* Node.js **>= 18** (LTS)
* npm 或 pnpm

```bash
node -v   # 确认 >= 18
```

---

## 1) Project setup / 初始化工程

```bash
mkdir miner-api && cd miner-api
npm init -y
```

创建文件结构：

```
miner-api/
├─ src/
│  ├─ app.ts           # Express 应用（导出 app，便于测试）
│  ├─ server.ts        # 启动入口（监听端口）
│  └─ auth.ts          # JWT/mTLS 中间件（可按 AUTH_MODE 切换）
├─ tests/
│  └─ app.test.ts      # Vitest + Supertest 端到端测试
├─ package.json
├─ tsconfig.json
├─ .env.example
├─ Dockerfile
├─ .dockerignore
└─ README.md
```

---

## 2) package.json（含脚本与依赖）

```json
{
  "name": "hashinsight-miner-api",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "ts-node-esm src/server.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "test": "vitest run"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "csv-stringify": "^6.4.0",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "papaparse": "^5.4.1",
    "xlsx": "^0.18.5"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/multer": "^1.4.7",
    "supertest": "^7.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.3",
    "vitest": "^2.0.5"
  }
}
```

安装依赖：

```bash
npm i
```

---

## 3) tsconfig.json（ESM + NodeNext）

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src", "tests"]
}
```

---

## 4) src/auth.ts（JWT/mTLS 按模式切换）

```ts
import type { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

// 读取模式（默认 dev_open）
const MODE = (process.env.AUTH_MODE || 'dev_open') as 'dev_open'|'jwt'|'jwt_mtls';

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  if (MODE === 'dev_open') return next();

  const auth = req.headers.authorization || '';
  if (!auth.startsWith('Bearer ')) return res.status(401).json({ message: 'Unauthorized' });
  const token = auth.slice(7);
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET || 'dev-secret');
    (req as any).user = payload;
  } catch (e) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  if (MODE === 'jwt_mtls') {
    // 演示：用反向代理/网关注入的头判断（生产用 req.client.authorized）
    const mtlsOk = String(req.headers['x-mtls-ok'] || '').toLowerCase() === 'true';
    if (!mtlsOk) return res.status(401).json({ message: 'mTLS required' });
  }
  next();
}

// 站点归属检查（生产应查数据库/缓存）
const ENFORCE = String(process.env.SITE_TENANT_ENFORCE || 'false') === 'true';
export function ensureSiteAccess(req: Request, siteId: string) {
  if (!ENFORCE) return true;
  const allowed = String(req.headers['x-tenant-sites'] || '')
    .split(',')
    .map(s => s.trim())
    .filter(Boolean);
  return allowed.includes(siteId);
}
```

---

## 5) src/app.ts（实现 OpenAPI 接口，导出 app）

```ts
import express from 'express';
import cors from 'cors';
import multer from 'multer';
import Papa from 'papaparse';
import * as XLSX from 'xlsx';
import { stringify } from 'csv-stringify/sync';
import { requireAuth, ensureSiteAccess } from './auth.js';

const app = express();
const upload = multer();

app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(requireAuth);

// --- Config switches ---
const DEFAULT_DEDUP = (process.env.IMPORT_DEDUP_STRATEGY || 'prefer_import') as 'prefer_import'|'prefer_existing'|'reject_conflict';
const DEFAULT_TEMPLATE_MODE = (process.env.TEMPLATE_MODE || 'with_example') as 'with_example'|'header_only';

// --- In-memory stores (replace with DB) ---
const miners: Record<string, any[]> = {}; // siteId -> Miner[]
const errorCsvBlob: Map<string, string> = new Map(); // jobId -> CSV string

const isIPv4 = (s: string) => /^(25[0-5]|2[0-4]\d|1?\d?\d)(\.(25[0-5]|2[0-4]\d|1?\d?\d)){3}$/.test(String(s||'').trim());
const keyOf = (m: any) => `${m.ip || ''}|${m.id || m.miner_id || ''}`;

// --- Helpers ---
function normalizeRow(r: any) {
  const ip = (r.ip || r.IP || r.Ip || r['Ip Address'] || '').toString().trim();
  const id = (r.miner_id || r.id || r.ID || r['Miner ID'] || ip).toString().trim();
  const obj = {
    id,
    miner_id: id,
    model: (r.model || r.Model || '').toString().trim(),
    ip,
    port: (r.port || r.Port || '').toString().trim(),
    api: (r.api || r.API || '').toString().trim(),
    username: (r.username || r.user || '').toString().trim(),
    note: (r.note || r.notes || '').toString().trim(),
    status: 'unknown',
    source: 'import'
  };
  return obj;
}

function mergeRows(siteId: string, incoming: any[], strategy: 'prefer_import'|'prefer_existing'|'reject_conflict') {
  const list = miners[siteId] || [];
  const map = new Map(list.map(m => [keyOf(m), m]));
  const conflicted: any[] = [];
  incoming.forEach(m => {
    const k = keyOf(m);
    if (!map.has(k)) { map.set(k, m); return; }
    const prev = map.get(k)!;
    const hasConflict = ['model','ip','port','api','username','note'].some(f => (m as any)[f] && (prev as any)[f] && (m as any)[f] !== (prev as any)[f]);
    if (hasConflict) {
      if (strategy === 'reject_conflict') { conflicted.push({ reason: 'conflict', ...m }); return; }
      if (strategy === 'prefer_existing') { return; }
      // prefer_import fallthrough
    }
    map.set(k, { ...prev, ...m });
  });
  const merged = Array.from(map.values());
  miners[siteId] = merged;
  return { before: list.length, after: merged.length, conflicted };
}

// --- Routes ---
app.get('/api/miners/template.csv', (req, res) => {
  const header = ['miner_id','model','ip','port','api','username','password','note'];
  const data = [
    ['S21-192.168.1.45','Antminer S21','192.168.1.45','4028','bmminer','','','rack A-03'],
    ['M50-192.168.1.55','Whatsminer M50','192.168.1.55','22333','http','','','rack B-02']
  ];
  const mode = (String(req.query.mode || DEFAULT_TEMPLATE_MODE) as 'with_example'|'header_only');
  const rows = mode === 'header_only' ? [header] : [header, ...data];
  const csv = stringify(rows);
  res.setHeader('content-type','text/csv; charset=utf-8');
  res.setHeader('content-disposition','attachment; filename="hashinsight_miners_template.csv"');
  res.send(csv);
});

app.post('/api/miners/import', upload.single('file'), (req, res) => {
  const siteId = (req.body.siteId || req.query.siteId || '').toString();
  if (!siteId) return res.status(400).json({ message: 'siteId required' });
  if (!ensureSiteAccess(req as any, siteId)) return res.status(403).json({ message: 'Forbidden: site not allowed' });

  const strategy = (req.query.dedupStrategy || req.body?.dedupStrategy || DEFAULT_DEDUP) as 'prefer_import'|'prefer_existing'|'reject_conflict';

  let rows: any[] = [];
  let total = 0;

  if (req.is('application/json') && Array.isArray((req.body as any).rows)) {
    rows = (req.body as any).rows;
    total = rows.length;
  } else if (req.file) {
    const buf = req.file.buffer;
    const name = (req.file.originalname || '').toLowerCase();
    if (name.endsWith('.csv')) {
      const text = buf.toString('utf-8');
      const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
      rows = (parsed.data as any[]);
      total = rows.length;
    } else if (name.endsWith('.xlsx') || name.endsWith('.xls')) {
      const wb = XLSX.read(buf);
      const ws = wb.Sheets[wb.SheetNames[0]];
      rows = XLSX.utils.sheet_to_json(ws) as any[];
      total = rows.length;
    } else {
      return res.status(400).json({ message: 'Only CSV/Excel supported' });
    }
  } else {
    return res.status(400).json({ message: 'Missing file or JSON rows' });
  }

  const normalized = rows.map(normalizeRow);
  const errors: any[] = [];
  const valids = normalized.filter((r, i) => {
    if (!isIPv4(r.ip)) { errors.push({ row: i+1, reason: 'invalid ip', ...r }); return false; }
    return true;
  });

  const { before, after, conflicted } = mergeRows(siteId, valids, strategy);
  conflicted.forEach((r, i) => errors.push({ row: i+1, ...r }));

  const deduped = after;
  const inserted = Math.max(0, after - before);
  const updated = Math.max(0, valids.length - inserted - conflicted.length);

  const jobId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
  if (errors.length) {
    const csv = stringify(errors, { header: true, columns: ['row','miner_id','model','ip','port','api','username','note','reason'] });
    errorCsvBlob.set(jobId, csv);
  }

  const preview = miners[siteId].slice(0, 10).map(m => ({ miner_id: m.miner_id, model: m.model, ip: m.ip, port: m.port, api: m.api, username: m.username, note: m.note }));

  res.json({
    jobId,
    totalRows: total,
    parsedRows: normalized.length,
    invalidRows: errors.length,
    deduped,
    inserted,
    updated,
    errorCsvUrl: errors.length ? `/api/miners/import/errors.csv?jobId=${jobId}` : null,
    preview
  });
});

app.get('/api/miners/import/errors.csv', (req, res) => {
  const jobId = String(req.query.jobId || '');
  if (!jobId || !errorCsvBlob.has(jobId)) return res.status(404).send('Not Found');
  const csv = errorCsvBlob.get(jobId)!;
  res.setHeader('content-type','text/csv; charset=utf-8');
  res.setHeader('content-disposition',`attachment; filename=import_errors_${jobId}.csv`);
  res.send(csv);
});

app.get('/api/miners', (req, res) => {
  const siteId = String(req.query.siteId || '');
  const page = Number(req.query.page || 1);
  const pageSize = Number(req.query.pageSize || 50);
  if (!siteId) return res.status(400).json({ message: 'siteId required' });
  if (!ensureSiteAccess(req as any, siteId)) return res.status(403).json({ message: 'Forbidden: site not allowed' });
  const list = miners[siteId] || [];
  const start = (page-1)*pageSize;
  const items = list.slice(start, start+pageSize);
  res.json({ items, total: list.length });
});

app.post('/api/miners/link', (req, res) => {
  const { siteId, minerIds } = req.body || {};
  if (!siteId || !Array.isArray(minerIds)) return res.status(400).json({ message: 'siteId & minerIds required' });
  if (!ensureSiteAccess(req as any, siteId)) return res.status(403).json({ message: 'Forbidden: site not allowed' });
  const list = miners[siteId] || [];
  let added = 0, already = 0;
  minerIds.forEach((id: string) => {
    const has = list.find(m => m.id === id);
    if (has) { already++; }
    else { list.push({ id, miner_id: id, ip: '', model: '', status: 'unknown', source: 'import' }); added++; }
  });
  miners[siteId] = list;
  res.json({ added, alreadyLinked: already, siteId });
});

export default app;
```

---

## 6) src/server.ts（监听端口）

```ts
import 'dotenv/config';
import app from './app.js';

const PORT = Number(process.env.PORT || 8080);
app.listen(PORT, () => console.log(`Miner API listening on :${PORT}`));
```

---

## 7) tests/app.test.ts（Vitest + Supertest，新增策略用例）

```ts
import { describe, it, expect } from 'vitest';
import request from 'supertest';
import app from '../src/app.js';

describe('Miner API', () => {
  it('returns CSV template (header_only)', async () => {
    const res = await request(app).get('/api/miners/template.csv?mode=header_only');
    expect(res.status).toBe(200);
    expect(res.headers['content-type']).toContain('text/csv');
    expect(res.text).toContain('miner_id');
    expect(res.text).not.toContain('Antminer S21');
  });

  it('imports JSON rows and reports invalid IP', async () => {
    const res = await request(app)
      .post('/api/miners/import?dedupStrategy=prefer_import')
      .set('Content-Type', 'application/json')
      .send({ siteId: 'qa', rows: [{ miner_id: 'X', ip: '999.1.1.1' }] });
    expect(res.status).toBe(200);
    expect(res.body.invalidRows).toBe(1);
    expect(res.body.errorCsvUrl).toContain('/api/miners/import/errors.csv');
  });

  it('prefer_existing keeps original on conflict', async () => {
    // seed
    await request(app)
      .post('/api/miners/import?dedupStrategy=prefer_import')
      .set('Content-Type', 'application/json')
      .send({ siteId: 'qa', rows: [{ miner_id: 'S21-1', ip: '192.168.1.10', model: 'Antminer S21' }] });

    // conflicting import with prefer_existing
    await request(app)
      .post('/api/miners/import?dedupStrategy=prefer_existing')
      .set('Content-Type', 'application/json')
      .send({ siteId: 'qa', rows: [{ miner_id: 'S21-1', ip: '192.168.1.10', model: 'Whatsminer M50' }] });

    const list = await request(app).get('/api/miners?siteId=qa&page=1&pageSize=50');
    const target = list.body.items.find((x: any) => x.ip === '192.168.1.10');
    expect(target.model).toBe('Antminer S21'); // original kept
  });

  it('reject_conflict outputs errors and does not overwrite', async () => {
    const res = await request(app)
      .post('/api/miners/import?dedupStrategy=reject_conflict')
      .set('Content-Type', 'application/json')
      .send({ siteId: 'qa', rows: [{ miner_id: 'S21-1', ip: '192.168.1.10', model: 'Different' }] });
    expect(res.status).toBe(200);
    expect(res.body.invalidRows).toBeGreaterThanOrEqual(1);
    expect(res.body.errorCsvUrl).toContain('/api/miners/import/errors.csv');

    const list = await request(app).get('/api/miners?siteId=qa&page=1&pageSize=50');
    const target = list.body.items.find((x: any) => x.ip === '192.168.1.10');
    expect(target.model).toBe('Antminer S21'); // unchanged
  });

  it('links selected miners', async () => {
    const res = await request(app)
      .post('/api/miners/link')
      .send({ siteId: 'qa', minerIds: ['S21-1'] });
    expect(res.status).toBe(200);
    expect(res.body.siteId).toBe('qa');
  });
});
```

运行测试：

```bash
npm run test
```

---

## 8) .env.example（环境变量开关）

```env
PORT=8080
JWT_SECRET=please-change-me

# 去重策略默认：prefer_import | prefer_existing | reject_conflict
IMPORT_DEDUP_STRATEGY=prefer_import

# 模板模式默认：with_example | header_only
TEMPLATE_MODE=with_example

# 鉴权模式：dev_open | jwt | jwt_mtls
AUTH_MODE=dev_open
# 站点租户校验开关（生产建议 true）
SITE_TENANT_ENFORCE=false
```

---

## 9) Dockerfile（生产镜像）

```dockerfile
FROM node:20-alpine AS deps
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci --omit=dev

FROM node:20-alpine AS builder
WORKDIR /app
COPY . .
RUN npm i && npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY .env.example ./.env
EXPOSE 8080
CMD ["node","dist/server.js"]
```

> 可选：生产环境请挂载外部 `.env`，或注入运行时环境变量。

---

## 10) .dockerignore

```
node_modules
npm-debug.log
.DS_Store
.git
.gitignore
.vscode
coverage
.dist
.env
```

---

## 11) Run locally / 本地运行

```bash
npm run dev         # 开发模式（热启动，ts-node-esm）
# 或
npm run build && npm start
```

Docker 运行：

```bash
docker build -t hashinsight/miner-api:dev .
docker run -p 8080:8080 --env PORT=8080 \
  --env IMPORT_DEDUP_STRATEGY=reject_conflict \
  --env TEMPLATE_MODE=header_only \
  --env AUTH_MODE=dev_open \
  hashinsight/miner-api:dev
```

---

## 12) Frontend wiring / 前端接入示例

**表单上传 CSV/Excel**（支持去重策略临时覆盖）：

```ts
const fd = new FormData();
fd.append('siteId', siteId);
fd.append('file', fileInput.files[0]);
await fetch(`/api/miners/import?dedupStrategy=reject_conflict`, { method: 'POST', body: fd });
```

**JSON 导入**：

```ts
await fetch('/api/miners/import?dedupStrategy=prefer_existing', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ siteId, rows })
});
```

**模板下载（仅表头）**：

```ts
location.href = '/api/miners/template.csv?mode=header_only';
```

**错误行下载按钮**：直接使用返回的 `errorCsvUrl`。

---

## 13) Next steps / 进阶（落地生产）

* **接入数据库**：Postgres/TimescaleDB；表上为 `(site_id, ip, miner_id)` 建唯一索引。
* **鉴权收紧**：生产中改用强制 JWT/mTLS；为每个 `siteId` 校验租户归属（可通过 RBAC/ACL 表）。
* **审计日志**：记录导入人、时间、站点、行数、错误样本；便于合规。
* **限流**：入口限流（例如 10 req/s）；文件大小/行数限制（如 10MB/20k 行）。
* **可观测**：导入任务时长、错误比例、内存占用、请求速率，暴露 Prometheus 指标。

---

### Done. 现在你可以：

1. `npm run dev` 启动接口；
2. 用你页面里的“批量导入”卡片直接打这些接口；
3. `npm run test` 跑自动化用例（含三种去重策略覆盖）；
4. 打包 Docker 并在服务器上运行。
