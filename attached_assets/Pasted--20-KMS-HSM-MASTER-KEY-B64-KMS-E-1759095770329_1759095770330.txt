太好了，这 20% 正是“外部资源对接”的硬骨头。我给你一份可直接落地的执行手册（带命令/配置/文档产物清单），覆盖：

KMS/HSM 接入（把 MASTER_KEY_B64 换成云 KMS 的 Envelope）

WireGuard 专网（站点网关容器 + 云端集线）

SOC 2 / 渗透测试（证据与外包执行）

1) KMS/HSM 接入（Envelope 改造）
1.1 目标

由云 KMS 生成/托管 主密钥（CMK），你的应用只拿到**数据密钥（Data Key）**用于 AES-GCM 加密；

envelope.py 中的 wrap/unwrap 从“本地 MASTER_KEY”改成“调用 KMS Encrypt/Decrypt”。

1.2 AWS KMS 方案（示例）
a) 创建 CMK（对称、可旋转）
aws kms create-key --description "HashInsight Master Key" \
  --key-usage ENCRYPT_DECRYPT --origin AWS_KMS \
  --tags TagKey=env,TagValue=prod
# 记录返回的 KeyId（例如 arn:aws:kms:us-east-1:123:key/abcd-...）
aws kms enable-key-rotation --key-id <KeyId>

b) 最小 IAM 权限（给应用实例/容器的角色）
{
  "Version": "2012-10-17",
  "Statement": [
    {"Effect": "Allow", "Action": ["kms:Encrypt","kms:Decrypt","kms:GenerateDataKey"],
     "Resource": "arn:aws:kms:us-east-1:123:key/<KeyId>"}
  ]
}

c) Key Policy（只允许你账户 & CI/CD 机器人管理）

关键点：限制 kms:Decrypt 仅应用角色可用；运维人员即便有 DB 访问也无法解密。

d) 代码改造（最小化修改 wrap/unwrap）
# common/crypto/envelope.py (KMS 版)
import os, json, secrets, base64
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import boto3

_kms = boto3.client("kms", region_name=os.getenv("AWS_REGION","us-east-1"))
KMS_KEY_ID = os.environ["KMS_KEY_ID"]  # 上文创建的 CMK

def encrypt_secret(plaintext:bytes)->dict:
    # 向 KMS 申请一个数据密钥（明文+密文）
    dk = _kms.generate_data_key(KeyId=KMS_KEY_ID, KeySpec="AES_256")
    data_key_plain = dk["Plaintext"]           # 明文数据密钥（仅内存使用）
    data_key_encrypted = dk["CiphertextBlob"]  # 被 KMS 包裹的 EDK（存库）
    aead = AESGCM(data_key_plain)
    iv = secrets.token_bytes(12)
    ct = aead.encrypt(iv, plaintext, None)
    # 擦除明文 data key（Python 无法完全保证，但可尽量释放引用）
    del data_key_plain
    return {
        "alg":"AESGCM256",
        "iv": base64.urlsafe_b64encode(iv).decode(),
        "ct": base64.urlsafe_b64encode(ct).decode(),
        "edk": base64.urlsafe_b64encode(data_key_encrypted).decode(),
        "last4": plaintext[-4:].decode(errors="ignore")
    }

def decrypt_secret(blob:dict)->bytes:
    edk = base64.urlsafe_b64decode(blob["edk"])
    dk = _kms.decrypt(CiphertextBlob=edk)
    data_key_plain = dk["Plaintext"]
    aead = AESGCM(data_key_plain)
    pt = aead.decrypt(
        base64.urlsafe_b64decode(blob["iv"]),
        base64.urlsafe_b64decode(blob["ct"]), None
    )
    del data_key_plain
    return pt

e) 迁移与回滚

迁移脚本：扫描 DB 中旧记录（有 wiv/edk 的为旧格式），逐条解密→用 KMS 版重加密→写回新结构（无 wiv）。

回滚：保留旧 MASTER_KEY_B64 7–14 天；脚本失败可用旧逻辑读取。

验收：抽样 100 条加解密一致；禁用旧 master key 的生产使用路径。

1.3 GCP / Azure 类比

GCP KMS：projects/.../locations/.../keyRings/.../cryptoKeys/...；用 generateRandomBytes 自造 data key 或在应用侧生成 data key → Encrypt 包裹。

Azure Key Vault：使用 Key Wrap/Unwrap（RSA-OAEP 或 AES-KW）或 Encrypt/Decrypt，同样落库存 EDK。

2) WireGuard 专网（站点网关 + 云端集线）
2.1 架构

每个矿场部署一个站点网关容器（连矿机局域网，只出不进）；

与云端 WireGuard Hub 建立隧道（10.8.0.0/24 虚拟网段）；

业务 API 继续走 HTTPS（双层：隧道 + TLS）。

2.2 云端 Hub（Ubuntu 示例）
# 安装
apt update && apt install -y wireguard qrencode
umask 077
wg genkey | tee /etc/wireguard/server.key | wg pubkey > /etc/wireguard/server.pub
cat >/etc/wireguard/wg0.conf <<'EOF'
[Interface]
Address = 10.8.0.1/24
ListenPort = 51820
PrivateKey = <SERVER_PRIVATE_KEY>
# 开启转发
PostUp = sysctl -w net.ipv4.ip_forward=1
PostDown = sysctl -w net.ipv4.ip_forward=0
EOF
# 启动
systemctl enable wg-quick@wg0 && systemctl start wg-quick@wg0


新增站点（Peer）：

# 生成站点密钥（可在云端生成再安全传递）
wg genkey | tee siteA.key | wg pubkey > siteA.pub
# 云端添加 Peer
wg set wg0 peer $(cat siteA.pub) allowed-ips 10.8.0.2/32 persistent-keepalive 25
# 查看配置
wg show

2.3 站点网关容器（docker-compose）
version: "3.8"
services:
  site-gateway:
    image: linuxserver/wireguard
    container_name: site-gateway
    cap_add: [NET_ADMIN, SYS_MODULE]
    environment:
      - PEERS=1
      - PEERDNS=1.1.1.1
      - INTERNAL_SUBNET=10.8.0.0
    volumes:
      - ./config:/config   # 放置 site 私钥/公钥
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
    restart: unless-stopped


或用原生配置（更透明）：

# /config/wg0.conf (站点)
[Interface]
Address = 10.8.0.2/32
PrivateKey = <SITE_PRIVATE_KEY>
DNS = 1.1.1.1

[Peer]
PublicKey = <SERVER_PUBLIC_KEY>
Endpoint = <hub-public-ip>:51820
AllowedIPs = 10.8.0.1/32
PersistentKeepalive = 25


路由与访问控制

站点网关只允许访问云端 API 的私有地址（例如 10.8.0.1:8443）；

矿机局域网不暴露；站点网关做采集/聚合后再出站发送。

验收

ping 10.8.0.1 通；业务 API 通过 10.8.0.1 可达；公网端口可关闭到仅 WireGuard/80/443。

3) SOC 2 / 渗透测试（落地到合同与证据）
3.1 SOC 2 Type I/II 路线图（最小可行）

范围（Scope）

三个服务 + 数据库 + CI/CD + 日志/监控 + 次级处理方（云、日志、IPFS/L2 只做“可选”模块说明）。

控制域（常见 5 类 Trust Services Criteria）

安全（必须）、可用性、保密性、处理完整性、隐私（按你业务选择）。

你已具备：加密、mTLS/JWT、RBAC、RLS、日志脱敏、审计、备份/恢复演练、变更管理、事件响应草案。

3 周准备（Type I）

政策与流程（Markdown/Doc 模板，放 /docs/soc2/）：

信息安全政策（ISP）、访问控制、加密管理、变更管理、日志与监控、备份与恢复、事件响应、供应商管理、开发安全（SDLC/SAST/DAST）、漏洞管理、资产管理、密码策略、终端策略。

证据包（Evidence）：

系统架构图、数据流程图、密钥清单（不含明文）、KMS 配置截图、IAM/Key Policy、审计日志样例、备份/恢复演练记录、告警截图、发布闸门记录、最小权限矩阵（角色→权限）。

风险评估：风险台账（威胁→控制→残余风险）；每季度评审记录（首次即可）。

员工培训：安全意识培训记录（在线测验结果/签到）。

准备审计机构：签订 Type I 审计意向书，预约现场/远程证据走查。

Type II（6–12 个月运行期）

运行中保存证据：访问审计、变更票据、漏洞修复单、备份演练记录、告警响应时间统计等。

3.2 渗透测试（Pentest）

RFP 范围

黑盒 + 灰盒（提供用户端与管理端账号、API 文档、一个受控的站点网关）

目标：Web 应用、API、认证/授权绕过、IDOR、注入、RCE、SSRF、逻辑漏洞、越权；

网络：WireGuard 隧道边界测试（ACL、横向移动）、Caddy/Nginx 配置、TLS。

时长：2–3 周；交付：报告（高/中/低）、复测一次。

你要准备的

测试环境（接近生产配置，脱敏数据或合成数据）；

法律函与 IP 白名单；

协调窗口与修复窗口；

报告接收与整改追踪（Jira/Linear）。

验收

0 个高危；中危均有缓解方案与修复计划；对外可公开“摘要报告”。

4) 时间表 & 产物清单
Week 1（KMS + 基线文档）

接入 AWS KMS（或 GCP/Azure 等价实现），完成数据迁移脚本与回滚策略；

输出：envelope.py（KMS 版）、kms_iam.json、Key Policy 截图、迁移报告（抽样 100 条一致性）。

Week 2（WireGuard 试点）

云端 Hub + 一个客户站点试点；

输出：wg0.conf（云/站点）、连接拓扑图、最小访问矩阵、演练记录（断链/重连）。

Week 3（SOC 2 Type I 准备包 + Pentest RFP）

/docs/soc2/ 完整文档与证据目录；

输出：政策文档 12 份、流程 6 份、证据截图/日志、风险评估与培训记录；Pentest RFP 与供应商比选表。